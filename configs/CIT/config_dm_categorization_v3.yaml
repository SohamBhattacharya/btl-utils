categories:
  X: ('D' in '{sm_cat}') or ('R' in '{sm_cat}')
  A: "(not {deltaT_sig_high}) and (not {deltaT_avg_sig_high}) and (not {X}) and ({nfoamlayers} == 1)"
  B: "(not {deltaT_sig_high}) and (not {deltaT_avg_sig_high}) and (not {X}) and ({nfoamlayers} == 2)"
  R: "({deltaT_sig_high} or {deltaT_avg_sig_high}) and (not {X})"
  #R: "not {A}"


metrics:
  
  deltaT_sig_high: "bool(max({TL_sig}, {TR_sig}, {BL_sig}, {BR_sig}) > {dm_deltaT_sig_max})"
  deltaT_avg_sig_high: "bool({avg_sig} > {dm_deltaT_avg_sig_max})"
  
  deltaT_high: "bool(max({TL}, {TR}, {BL}, {BR}) > {dm_deltaT_max})"
  deltaT_avg_high: "bool(numpy.mean([{TL}, {TR}, {BL}, {BR}]) > {dm_deltaT_avg_max})"
  
  deltaT_avg: "float(numpy.mean([{TL}, {TR}, {BL}, {BR}]))"
  deltaT_std: "float(numpy.std([{TL}, {TR}, {BL}, {BR}]))"
  deltaT_min: "float(numpy.min([{TL}, {TR}, {BL}, {BR}]))"
  deltaT_max: "float(numpy.max([{TL}, {TR}, {BL}, {BR}]))"
  
  sm_cat: "str({sm1}['results']['category']+{sm2}['results']['category'])"
  
  tec_sum: "float(numpy.sum([{sm1}['sipm1']['tec_res'], {sm1}['sipm2']['tec_res'], {sm2}['sipm1']['tec_res'], {sm2}['sipm2']['tec_res']]))"
  tec_std: "float(numpy.std([{sm1}['sipm1']['tec_res'], {sm1}['sipm2']['tec_res'], {sm2}['sipm1']['tec_res'], {sm2}['sipm2']['tec_res']]))"
  
  lo_avg: "-0.5*({sm1}['results']['lo_bar_avg'] + {sm2}['results']['lo_bar_avg'])"
  
  nfoamlayers: "{extra}['nfoamlayers']"
  
  # Negative for reverse sorting
  grouping: "-0.5*({sm1}['results']['lo_bar_avg'] + {sm2}['results']['lo_bar_avg'])"


# Will print the metrics for each RU
# The RU DMs can be accessed as ru.dms
# The above metrics can be accessed here as dm.results['metric_name'], where dm is an element of ru.dms
# Results/metrics of the constituent SMs can be accessed here as dm.sm<1/2>.results['metric_name'] 
ru_metrics:
  
  lo_avg_ru: "numpy.mean([[_sm.results['lo_bar_avg'] for _sm in [_dm.sm1, _dm.sm2]] for _dm in ru.dms])"
  lo_std_ru: "numpy.std([[_sm.results['lo_bar_avg'] for _sm in [_dm.sm1, _dm.sm2]] for _dm in ru.dms])"
  lo_min_ru: "numpy.min([[_sm.results['lo_bar_avg'] for _sm in [_dm.sm1, _dm.sm2]] for _dm in ru.dms])"
  lo_max_ru: "numpy.max([[_sm.results['lo_bar_avg'] for _sm in [_dm.sm1, _dm.sm2]] for _dm in ru.dms])"
  
  lo_std_rel_ru: "100*{lo_std_ru}/{lo_avg_ru}"
  lo_delta_rel_ru: "100*({lo_max_ru}-{lo_min_ru})/{lo_avg_ru}"
  
  deltaT_avg_ru: "numpy.mean([_dm.results['deltaT_avg'] for _dm in ru.dms])"
  deltaT_std_ru: "numpy.std([_dm.results['deltaT_avg'] for _dm in ru.dms])"
  deltaT_min_ru: "numpy.min([_dm.results['deltaT_min'] for _dm in ru.dms])"
  deltaT_max_ru: "numpy.max([_dm.results['deltaT_max'] for _dm in ru.dms])"

  tec_avg_ru: "numpy.mean([_dm.results['tec_sum'] for _dm in ru.dms])"
  tec_std_ru: "numpy.std([_dm.results['tec_sum'] for _dm in ru.dms])"


# Will print the metrics for each Tray
# The Tray RUs can be accessed as tray.rus
# The RU metrics can be accessed here as ru.results['metric_name'], where ru is an element of tray.rus
tray_metrics:
  
  lo_avg_tray: "numpy.mean([_ru.results['lo_avg_ru'] for _ru in tray.rus])"
  lo_ru_std_tray: "numpy.std([_ru.results['lo_avg_ru'] for _ru in tray.rus])"
  lo_ru_min_tray: "numpy.min([_ru.results['lo_avg_ru'] for _ru in tray.rus])"
  lo_ru_max_tray: "numpy.max([_ru.results['lo_avg_ru'] for _ru in tray.rus])"
  
  lo_ru_std_rel_tray: "100*{lo_ru_std_tray}/{lo_avg_tray}"
  lo_ru_delta_rel_tray: "100*({lo_ru_max_tray}-{lo_ru_min_tray})/{lo_avg_tray}"


def:
  TL: "{gTL}.Eval(4)"
  TR: "{gTR}.Eval(4)"
  BL: "{gBL}.Eval(4)"
  BR: "{gBR}.Eval(4)"
  
  TL_sig: "({gTL}.Eval(4) - {dm_deltaT_TL_mu}) / {dm_deltaT_TL_sigma}"
  TR_sig: "({gTR}.Eval(4) - {dm_deltaT_TR_mu}) / {dm_deltaT_TR_sigma}"
  BL_sig: "({gBL}.Eval(4) - {dm_deltaT_BL_mu}) / {dm_deltaT_BL_sigma}"
  BR_sig: "({gBR}.Eval(4) - {dm_deltaT_BR_mu}) / {dm_deltaT_BR_sigma}"
  avg_sig: "(numpy.mean([{gTL}.Eval(4), {gTR}.Eval(4), {gBL}.Eval(4), {gBR}.Eval(4)]) - {dm_deltaT_avg_mu}) / {dm_deltaT_avg_sigma}"


read:
  gTL: "g_DeltaTTopL"
  gTR: "g_DeltaTTopR"
  gBL: "g_DeltaTBottomL"
  gBR: "g_DeltaTBottomR"
